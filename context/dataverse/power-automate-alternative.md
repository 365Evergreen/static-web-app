# Power Automate Flow Alternative

## Overview
As an alternative to the Azure Function approach, you can create a Power Automate flow to handle contact form submissions. This provides a low-code solution while still meeting the PRP requirements.

## Flow Design

### Trigger: HTTP Request
- **Method**: POST
- **URL**: Will be generated by Power Automate
- **Schema**: 
```json
{
    "type": "object",
    "properties": {
        "name": {"type": "string"},
        "email": {"type": "string"},
        "company": {"type": "string"},
        "phone": {"type": "string"},
        "service": {"type": "string"},
        "message": {"type": "string"}
    },
    "required": ["name", "email", "message"]
}
```

### Actions Sequence

#### 1. Initialize Variables
- **IP Address**: `string` - `triggerOutputs()?['headers']?['X-Forwarded-For']`
- **Timestamp**: `string` - `utcNow()`
- **Service Value**: `integer` - For mapping service to option set

#### 2. Condition: Validate Required Fields
- **Condition**: 
  ```
  and(
    not(empty(triggerBody()?['name'])),
    not(empty(triggerBody()?['email'])),
    not(empty(triggerBody()?['message']))
  )
  ```

#### 3. Yes Branch: Process Valid Submission

##### A. Compose: Map Service to Option Set
```
switch(
  triggerBody()?['service'],
  'microsoft-365', 1,
  'power-platform', 2,
  'digital-transformation', 3,
  'training', 4,
  'custom-solutions', 5,
  'consultation', 6,
  null
)
```

##### B. Create Record: Contact Submissions
- **Table**: Contact Submissions (msl_contactsubmission)
- **Fields**:
  - Full Name: `triggerBody()?['name']`
  - Email Address: `triggerBody()?['email']`
  - Company Name: `triggerBody()?['company']`
  - Phone Number: `triggerBody()?['phone']`
  - Service Interest: `outputs('Compose_-_Map_Service')`
  - Message: `triggerBody()?['message']`
  - Submission Date: `variables('Timestamp')`
  - IP Address: `variables('IP Address')`
  - Status: 1 (New)

##### C. Response: Success
- **Status Code**: 200
- **Headers**: 
  ```json
  {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "*"
  }
  ```
- **Body**:
  ```json
  {
    "message": "Thank you! Your message has been received and saved. We will contact you soon.",
    "submissionId": "@{outputs('Create_record')?['body/msl_contactsubmissionid']}",
    "timestamp": "@{variables('Timestamp')}"
  }
  ```

#### 4. No Branch: Invalid Submission

##### Response: Error
- **Status Code**: 400
- **Headers**: 
  ```json
  {
    "Content-Type": "application/json",
    "Access-Control-Allow-Origin": "*"
  }
  ```
- **Body**:
  ```json
  {
    "error": "Name, email, and message are required fields"
  }
  ```

## Enhanced Version with Email Validation

### Additional Condition: Validate Email Format
Add after the required fields check:

```
and(
  contains(triggerBody()?['email'], '@'),
  contains(triggerBody()?['email'], '.'),
  greater(length(triggerBody()?['email']), 5)
)
```

## Flow Export Instructions

### 1. Create the Flow
1. Go to [Power Automate](https://make.powerautomate.com/)
2. **+ Create** → **Instant cloud flow**
3. **Skip** trigger selection
4. Add **HTTP Request** trigger
5. Configure as described above

### 2. Configure HTTP Trigger
1. **Method**: POST
2. **Request Body JSON Schema**: Use schema provided above
3. **Save** to generate URL

### 3. Add Actions
Follow the sequence described above, testing each step.

### 4. Enable CORS (if needed)
Add additional responses for OPTIONS method to handle CORS preflight:

- **Condition**: `equals(triggerOutputs()?['method'], 'OPTIONS')`
- **Response**: Status 200 with CORS headers

### 5. Export Flow
1. **Export** → **Package (.zip)**
2. Save as `contact-form-dataverse-flow.zip`
3. Include in project deliverables

## Frontend Integration

Update the contact form JavaScript to use the Power Automate URL:

```javascript
// Replace Azure Function URL with Power Automate trigger URL
const POWER_AUTOMATE_URL = 'https://prod-xx.eastus.logic.azure.com:443/workflows/xxx/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=xxx';

// Update fetch call
const response = await fetch(POWER_AUTOMATE_URL, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify(data)
});
```

## Comparison: Azure Function vs Power Automate

| Aspect | Azure Function | Power Automate |
|--------|----------------|----------------|
| **Development** | Code-based (TypeScript) | Low-code visual designer |
| **Authentication** | Managed Identity | Built-in Dataverse connector |
| **Validation** | Custom TypeScript logic | Power Automate expressions |
| **Error Handling** | Comprehensive try-catch | Conditional branches |
| **Performance** | Lower latency | Slightly higher latency |
| **Monitoring** | Application Insights | Power Automate analytics |
| **Cost** | Consumption-based | Per-run pricing |
| **Scalability** | Auto-scaling | Built-in scaling |
| **Customization** | Full control | Limited to available actions |

## Recommendation

- **Azure Function**: Better for complex validation, error handling, and performance
- **Power Automate**: Better for rapid development and easier maintenance by business users

Both approaches meet the PRP requirements for Dataverse integration with proper security and validation.
